
rsa_spa-CWLITEXMEGA.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000088a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00802000  0000088a  0000091e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000052  00802000  00802000  0000091e  2**0
                  ALLOC
  3 .comment      00000026  00000000  00000000  0000091e  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000944  2**2
                  CONTENTS, READONLY, OCTETS
  5 .debug_aranges 00000108  00000000  00000000  00000988  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  6 .debug_info   00003b7f  00000000  00000000  00000a90  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  7 .debug_abbrev 000028dc  00000000  00000000  0000460f  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  8 .debug_line   00001bf6  00000000  00000000  00006eeb  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  9 .debug_frame  00000344  00000000  00000000  00008ae4  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 10 .debug_str    00001fd3  00000000  00000000  00008e28  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 11 .debug_loc    00001063  00000000  00000000  0000adfb  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 12 .debug_ranges 00000090  00000000  00000000  0000be5e  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 ea 00 	jmp	0x1d4	; 0x1d4 <__ctors_end>
   4:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
   8:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
   c:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
  10:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
  14:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
  18:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
  1c:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
  20:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
  24:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
  28:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
  2c:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
  30:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
  34:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
  38:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
  3c:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
  40:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
  44:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
  48:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
  4c:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
  50:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
  54:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
  58:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
  5c:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
  60:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
  64:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
  68:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
  6c:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
  70:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
  74:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
  78:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
  7c:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
  80:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
  84:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
  88:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
  8c:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
  90:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
  94:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
  98:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
  9c:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
  a0:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
  a4:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
  a8:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
  ac:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
  b0:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
  b4:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
  b8:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
  bc:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
  c0:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
  c4:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
  c8:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
  cc:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
  d0:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
  d4:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
  d8:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
  dc:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
  e0:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
  e4:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
  e8:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
  ec:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
  f0:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
  f4:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
  f8:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
  fc:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
 100:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
 104:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
 108:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
 10c:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
 110:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
 114:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
 118:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
 11c:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
 120:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
 124:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
 128:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
 12c:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
 130:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
 134:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
 138:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
 13c:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
 140:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
 144:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
 148:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
 14c:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
 150:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
 154:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
 158:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
 15c:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
 160:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
 164:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
 168:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
 16c:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
 170:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
 174:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
 178:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
 17c:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
 180:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
 184:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
 188:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
 18c:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
 190:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
 194:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
 198:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
 19c:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
 1a0:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
 1a4:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
 1a8:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
 1ac:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
 1b0:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
 1b4:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
 1b8:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
 1bc:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
 1c0:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>
 1c4:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__bad_interrupt>

000001c8 <__trampolines_start>:
 1c8:	0c 94 48 02 	jmp	0x490	; 0x490 <check_version>
 1cc:	0c 94 00 01 	jmp	0x200	; 0x200 <handle>
 1d0:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <ss_get_commands>

000001d4 <__ctors_end>:
 1d4:	11 24       	eor	r1, r1
 1d6:	1f be       	out	0x3f, r1	; 63
 1d8:	cf ef       	ldi	r28, 0xFF	; 255
 1da:	cd bf       	out	0x3d, r28	; 61
 1dc:	df e3       	ldi	r29, 0x3F	; 63
 1de:	de bf       	out	0x3e, r29	; 62
 1e0:	00 e0       	ldi	r16, 0x00	; 0
 1e2:	0c bf       	out	0x3c, r16	; 60

000001e4 <__do_clear_bss>:
 1e4:	20 e2       	ldi	r18, 0x20	; 32

000001e6 <.Loc.1>:
 1e6:	a0 e0       	ldi	r26, 0x00	; 0

000001e8 <.Loc.2>:
 1e8:	b0 e2       	ldi	r27, 0x20	; 32

000001ea <.Loc.3>:
 1ea:	01 c0       	rjmp	.+2      	; 0x1ee <.Loc.5>

000001ec <.Loc.4>:
 1ec:	1d 92       	st	X+, r1

000001ee <.Loc.5>:
 1ee:	a2 35       	cpi	r26, 0x52	; 82

000001f0 <.Loc.6>:
 1f0:	b2 07       	cpc	r27, r18

000001f2 <.Loc.7>:
 1f2:	e1 f7       	brne	.-8      	; 0x1ec <.Loc.4>

000001f4 <L0^A>:
 1f4:	0e 94 30 04 	call	0x860	; 0x860 <main>
 1f8:	0c 94 43 04 	jmp	0x886	; 0x886 <_exit>

000001fc <__bad_interrupt>:
 1fc:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000200 <handle>:
/// This function will handle the 'p' command send from the capture board.
/// It returns the squared version of the scmd given.
/// It does this in approximately equal time, which allows us to see clear
/// differences between different scmd values.
uint8_t handle(uint8_t cmd, uint8_t scmd, uint8_t len, uint8_t *buf)
{
 200:	cf 93       	push	r28

00000202 <.LCFI0>:
 202:	df 93       	push	r29

00000204 <.LCFI1>:
 204:	00 d0       	rcall	.+0      	; 0x206 <L0^A>

00000206 <L0^A>:
 206:	cd b7       	in	r28, 0x3d	; 61
 208:	de b7       	in	r29, 0x3e	; 62

0000020a <.LCFI3>:
  volatile uint8_t result = 0;
 20a:	1b 82       	std	Y+3, r1	; 0x03

0000020c <.Loc.4>:

  // Start measurement.
  trigger_high();
 20c:	81 e0       	ldi	r24, 0x01	; 1

0000020e <.LVL1>:
 20e:	80 93 05 06 	sts	0x0605, r24	; 0x800605 <__TEXT_REGION_LENGTH__+0x700605>

00000212 <.LBB2>:

  // Cause more clock cycles to happen the higher the scmd is
  // We need 'volatile' here because we don't want the compiler to optimize the
  // loop out.
  for (volatile uint8_t i = 0; i < 255; i++) {
 212:	1a 82       	std	Y+2, r1	; 0x02

00000214 <.Loc.9>:
    if (i == scmd) {
        result = scmd * scmd;
 214:	66 9f       	mul	r22, r22
 216:	90 2d       	mov	r25, r0
 218:	11 24       	eor	r1, r1

0000021a <.L2>:
  for (volatile uint8_t i = 0; i < 255; i++) {
 21a:	8a 81       	ldd	r24, Y+2	; 0x02

0000021c <.Loc.12>:
 21c:	8f 3f       	cpi	r24, 0xFF	; 255
 21e:	99 f4       	brne	.+38     	; 0x246 <.L4>

00000220 <.LBE2>:
    }
  }

  // Stop measurement.
  trigger_low();
 220:	81 e0       	ldi	r24, 0x01	; 1
 222:	80 93 06 06 	sts	0x0606, r24	; 0x800606 <__TEXT_REGION_LENGTH__+0x700606>

00000226 <.Loc.14>:

  // For now we can just return the result back to the user.
  uint8_t buff[1] = { result };
 226:	8b 81       	ldd	r24, Y+3	; 0x03
 228:	89 83       	std	Y+1, r24	; 0x01

0000022a <.Loc.16>:
  simpleserial_put('r', 1, buff);
 22a:	ae 01       	movw	r20, r28

0000022c <.LVL2>:
 22c:	4f 5f       	subi	r20, 0xFF	; 255
 22e:	5f 4f       	sbci	r21, 0xFF	; 255
 230:	61 e0       	ldi	r22, 0x01	; 1

00000232 <.LVL3>:
 232:	82 e7       	ldi	r24, 0x72	; 114
 234:	0e 94 f0 01 	call	0x3e0	; 0x3e0 <simpleserial_put>

00000238 <.LVL4>:

  return 0;
}
 238:	80 e0       	ldi	r24, 0x00	; 0
 23a:	23 96       	adiw	r28, 0x03	; 3
 23c:	cd bf       	out	0x3d, r28	; 61
 23e:	de bf       	out	0x3e, r29	; 62
 240:	df 91       	pop	r29
 242:	cf 91       	pop	r28
 244:	08 95       	ret

00000246 <.L4>:
    if (i == scmd) {
 246:	8a 81       	ldd	r24, Y+2	; 0x02

00000248 <.Loc.23>:
 248:	86 13       	cpse	r24, r22
 24a:	01 c0       	rjmp	.+2      	; 0x24e <.L3>

0000024c <.Loc.24>:
        result = scmd * scmd;
 24c:	9b 83       	std	Y+3, r25	; 0x03

0000024e <.L3>:
  for (volatile uint8_t i = 0; i < 255; i++) {
 24e:	8a 81       	ldd	r24, Y+2	; 0x02
 250:	8f 5f       	subi	r24, 0xFF	; 255
 252:	8a 83       	std	Y+2, r24	; 0x02
 254:	e2 cf       	rjmp	.-60     	; 0x21a <.L2>

00000256 <ss_crc>:


// 0xA6 formerly 
#define CW_CRC 0x4D 
uint8_t ss_crc(uint8_t *buf, uint8_t len)
{
 256:	28 2f       	mov	r18, r24

00000258 <.LVL1>:
	unsigned int k = 0;
	uint8_t crc = 0x00;
 258:	80 e0       	ldi	r24, 0x00	; 0

0000025a <.LVL2>:
	while (len--) {
		crc ^= *buf++;
		for (k = 0; k < 8; k++) {
			crc = crc & 0x80 ? (crc << 1) ^ CW_CRC: crc << 1;
 25a:	4d e4       	ldi	r20, 0x4D	; 77

0000025c <.L2>:
	while (len--) {
 25c:	61 50       	subi	r22, 0x01	; 1
 25e:	08 f4       	brcc	.+2      	; 0x262 <.L6>

00000260 <.Loc.9>:
		}
	}
	return crc;

}
 260:	08 95       	ret

00000262 <.L6>:
		crc ^= *buf++;
 262:	e2 2f       	mov	r30, r18
 264:	f9 2f       	mov	r31, r25

00000266 <.LVL5>:
 266:	91 91       	ld	r25, Z+

00000268 <.LVL6>:
 268:	89 27       	eor	r24, r25

0000026a <.LVL7>:
 26a:	28 e0       	ldi	r18, 0x08	; 8
 26c:	30 e0       	ldi	r19, 0x00	; 0

0000026e <.L5>:
			crc = crc & 0x80 ? (crc << 1) ^ CW_CRC: crc << 1;
 26e:	87 ff       	sbrs	r24, 7
 270:	08 c0       	rjmp	.+16     	; 0x282 <.L3>

00000272 <.Loc.19>:
 272:	88 0f       	add	r24, r24

00000274 <.LVL9>:
 274:	84 27       	eor	r24, r20

00000276 <.L4>:
		for (k = 0; k < 8; k++) {
 276:	21 50       	subi	r18, 0x01	; 1
 278:	31 09       	sbc	r19, r1

0000027a <.LVL11>:
 27a:	c9 f7       	brne	.-14     	; 0x26e <.L5>

0000027c <.Loc.24>:
		crc ^= *buf++;
 27c:	2e 2f       	mov	r18, r30

0000027e <.LVL12>:
 27e:	9f 2f       	mov	r25, r31
 280:	ed cf       	rjmp	.-38     	; 0x25c <.L2>

00000282 <.L3>:
			crc = crc & 0x80 ? (crc << 1) ^ CW_CRC: crc << 1;
 282:	88 0f       	add	r24, r24

00000284 <.LVL14>:
 284:	f8 cf       	rjmp	.-16     	; 0x276 <.L4>

00000286 <hex_decode>:
#if SS_VER == SS_VER_2_0
#error "SS_VER_2_0 is deprecated! Use SS_VER_2_1 instead."
#elif SS_VER == SS_VER_2_1

int hex_decode(int len, char* ascii_buf, uint8_t* data_buf)
{
 286:	9c 01       	movw	r18, r24
 288:	fa 01       	movw	r30, r20

0000028a <.LBB2>:
	for(int i = 0; i < len; i++)
 28a:	db 01       	movw	r26, r22

0000028c <.Loc.33>:
 28c:	50 e0       	ldi	r21, 0x00	; 0
 28e:	40 e0       	ldi	r20, 0x00	; 0

00000290 <.L9>:
 290:	42 17       	cp	r20, r18
 292:	53 07       	cpc	r21, r19
 294:	1c f0       	brlt	.+6      	; 0x29c <.L19>

00000296 <.LBE2>:
			data_buf[i] |= (n_hi - 'a' + 10) << 4;
		else
			return 1;
	}

	return 0;
 296:	90 e0       	ldi	r25, 0x00	; 0
 298:	80 e0       	ldi	r24, 0x00	; 0

0000029a <.Loc.37>:
}
 29a:	08 95       	ret

0000029c <.L19>:
		char n_hi = ascii_buf[2*i];
 29c:	8c 91       	ld	r24, X

0000029e <.LVL18>:
		char n_lo = ascii_buf[2*i+1];
 29e:	11 96       	adiw	r26, 0x01	; 1
 2a0:	9c 91       	ld	r25, X
 2a2:	11 97       	sbiw	r26, 0x01	; 1

000002a4 <.LVL19>:
		if(n_lo >= '0' && n_lo <= '9')
 2a4:	60 ed       	ldi	r22, 0xD0	; 208
 2a6:	69 0f       	add	r22, r25

000002a8 <.Loc.44>:
 2a8:	6a 30       	cpi	r22, 0x0A	; 10
 2aa:	78 f4       	brcc	.+30     	; 0x2ca <.L10>

000002ac <.Loc.45>:
			data_buf[i] = n_lo - '0';
 2ac:	60 83       	st	Z, r22

000002ae <.L11>:
		if(n_hi >= '0' && n_hi <= '9')
 2ae:	90 ed       	ldi	r25, 0xD0	; 208
 2b0:	98 0f       	add	r25, r24

000002b2 <.Loc.49>:
 2b2:	9a 30       	cpi	r25, 0x0A	; 10
 2b4:	d0 f4       	brcc	.+52     	; 0x2ea <.L15>

000002b6 <.Loc.50>:
			data_buf[i] |= (n_hi - '0') << 4;
 2b6:	82 95       	swap	r24

000002b8 <.LVL21>:
 2b8:	80 7f       	andi	r24, 0xF0	; 240

000002ba <.L21>:
			data_buf[i] |= (n_hi - 'a' + 10) << 4;
 2ba:	90 81       	ld	r25, Z
 2bc:	89 2b       	or	r24, r25
 2be:	80 83       	st	Z, r24

000002c0 <.LBE3>:
	for(int i = 0; i < len; i++)
 2c0:	4f 5f       	subi	r20, 0xFF	; 255
 2c2:	5f 4f       	sbci	r21, 0xFF	; 255

000002c4 <.Loc.56>:
 2c4:	31 96       	adiw	r30, 0x01	; 1
 2c6:	12 96       	adiw	r26, 0x02	; 2
 2c8:	e3 cf       	rjmp	.-58     	; 0x290 <.L9>

000002ca <.L10>:
		else if(n_lo >= 'A' && n_lo <= 'F')
 2ca:	6f eb       	ldi	r22, 0xBF	; 191
 2cc:	69 0f       	add	r22, r25

000002ce <.Loc.59>:
 2ce:	66 30       	cpi	r22, 0x06	; 6
 2d0:	18 f4       	brcc	.+6      	; 0x2d8 <.L12>

000002d2 <.Loc.60>:
			data_buf[i] = n_lo - 'A' + 10;
 2d2:	97 53       	subi	r25, 0x37	; 55

000002d4 <.L20>:
			data_buf[i] = n_lo - 'a' + 10;
 2d4:	90 83       	st	Z, r25

000002d6 <.LVL25>:
 2d6:	eb cf       	rjmp	.-42     	; 0x2ae <.L11>

000002d8 <.L12>:
		else if(n_lo >= 'a' && n_lo <= 'f')
 2d8:	6f e9       	ldi	r22, 0x9F	; 159
 2da:	69 0f       	add	r22, r25

000002dc <.Loc.66>:
 2dc:	66 30       	cpi	r22, 0x06	; 6
 2de:	18 f0       	brcs	.+6      	; 0x2e6 <.L13>

000002e0 <.L18>:
			return 1;
 2e0:	81 e0       	ldi	r24, 0x01	; 1
 2e2:	90 e0       	ldi	r25, 0x00	; 0

000002e4 <.LVL28>:
 2e4:	08 95       	ret

000002e6 <.L13>:
			data_buf[i] = n_lo - 'a' + 10;
 2e6:	97 55       	subi	r25, 0x57	; 87

000002e8 <.LVL30>:
 2e8:	f5 cf       	rjmp	.-22     	; 0x2d4 <.L20>

000002ea <.L15>:
		else if(n_hi >= 'A' && n_hi <= 'F')
 2ea:	9f eb       	ldi	r25, 0xBF	; 191
 2ec:	98 0f       	add	r25, r24

000002ee <.Loc.74>:
 2ee:	96 30       	cpi	r25, 0x06	; 6
 2f0:	40 f4       	brcc	.+16     	; 0x302 <.L17>

000002f2 <.Loc.75>:
			data_buf[i] |= (n_hi - 'A' + 10) << 4;
 2f2:	87 53       	subi	r24, 0x37	; 55
 2f4:	99 0b       	sbc	r25, r25

000002f6 <.L22>:
			data_buf[i] |= (n_hi - 'a' + 10) << 4;
 2f6:	64 e0       	ldi	r22, 0x04	; 4

000002f8 <.L1^B1>:
 2f8:	88 0f       	add	r24, r24
 2fa:	99 1f       	adc	r25, r25
 2fc:	6a 95       	dec	r22
 2fe:	e1 f7       	brne	.-8      	; 0x2f8 <.L1^B1>
 300:	dc cf       	rjmp	.-72     	; 0x2ba <.L21>

00000302 <.L17>:
		else if(n_hi >= 'a' && n_hi <= 'f')
 302:	9f e9       	ldi	r25, 0x9F	; 159
 304:	98 0f       	add	r25, r24

00000306 <.Loc.80>:
 306:	96 30       	cpi	r25, 0x06	; 6
 308:	58 f7       	brcc	.-42     	; 0x2e0 <.L18>

0000030a <.Loc.81>:
			data_buf[i] |= (n_hi - 'a' + 10) << 4;
 30a:	87 55       	subi	r24, 0x57	; 87
 30c:	99 0b       	sbc	r25, r25

0000030e <.LVL34>:
 30e:	f3 cf       	rjmp	.-26     	; 0x2f6 <.L22>

00000310 <ss_puts>:
	uint8_t (*fp)(uint8_t, uint8_t, uint8_t, uint8_t *);
} ss_cmd;
static ss_cmd commands[MAX_SS_CMDS];

void ss_puts(char *x)
{
 310:	cf 93       	push	r28

00000312 <.LCFI0>:
 312:	df 93       	push	r29

00000314 <.LCFI1>:
 314:	ec 01       	movw	r28, r24

00000316 <.L24>:
	do {
		putch(*x);
 316:	89 91       	ld	r24, Y+

00000318 <.LVL37>:
 318:	0e 94 85 03 	call	0x70a	; 0x70a <output_ch_0>

0000031c <.LVL38>:
	} while (*++x);
 31c:	88 81       	ld	r24, Y
 31e:	81 11       	cpse	r24, r1
 320:	fa cf       	rjmp	.-12     	; 0x316 <.L24>

00000322 <.Loc.91>:
}
 322:	df 91       	pop	r29
 324:	cf 91       	pop	r28

00000326 <.LVL39>:
 326:	08 95       	ret

00000328 <stuff_data>:
    return 0x00;

}

uint8_t stuff_data(uint8_t *buf, uint8_t len)
{
 328:	9c 01       	movw	r18, r24

0000032a <.LVL41>:
	uint8_t i = 1;
	uint8_t last = 0;
	for (; i < len; i++) {
 32a:	fc 01       	movw	r30, r24
 32c:	31 96       	adiw	r30, 0x01	; 1

0000032e <.Loc.98>:
	uint8_t last = 0;
 32e:	90 e0       	ldi	r25, 0x00	; 0

00000330 <.Loc.99>:
	uint8_t i = 1;
 330:	81 e0       	ldi	r24, 0x01	; 1

00000332 <.L27>:
	for (; i < len; i++) {
 332:	86 17       	cp	r24, r22
 334:	10 f0       	brcs	.+4      	; 0x33a <.L29>

00000336 <.Loc.102>:
			buf[last] = i - last;
			last = i;
		}
	}
	return 0x00;
}
 336:	80 e0       	ldi	r24, 0x00	; 0

00000338 <.LVL43>:
 338:	08 95       	ret

0000033a <.L29>:
		if (buf[i] == FRAME_BYTE) {
 33a:	41 91       	ld	r20, Z+

0000033c <.Loc.107>:
 33c:	41 11       	cpse	r20, r1
 33e:	07 c0       	rjmp	.+14     	; 0x34e <.L28>

00000340 <.Loc.108>:
			buf[last] = i - last;
 340:	d9 01       	movw	r26, r18
 342:	a9 0f       	add	r26, r25
 344:	b1 1d       	adc	r27, r1

00000346 <.Loc.110>:
 346:	48 2f       	mov	r20, r24
 348:	49 1b       	sub	r20, r25

0000034a <.Loc.111>:
 34a:	4c 93       	st	X, r20

0000034c <.LVL45>:
 34c:	98 2f       	mov	r25, r24

0000034e <.L28>:
	for (; i < len; i++) {
 34e:	8f 5f       	subi	r24, 0xFF	; 255

00000350 <.Loc.116>:
 350:	f0 cf       	rjmp	.-32     	; 0x332 <.L27>

00000352 <unstuff_data>:

uint8_t unstuff_data(uint8_t *buf, uint8_t len)
{
 352:	fc 01       	movw	r30, r24

00000354 <.Loc.119>:
	uint8_t next = buf[0];
 354:	90 81       	ld	r25, Z

00000356 <.LVL49>:
	buf[0] = 0x00;
 356:	10 82       	st	Z, r1

00000358 <.LVL50>:
	uint8_t next = buf[0];
 358:	89 2f       	mov	r24, r25

0000035a <.L31>:
	//len -= 1;
	uint8_t tmp = next;
	while ((next < len) && tmp != 0) {
 35a:	86 17       	cp	r24, r22
 35c:	10 f4       	brcc	.+4      	; 0x362 <.L30>

0000035e <.Loc.127>:
 35e:	91 11       	cpse	r25, r1
 360:	01 c0       	rjmp	.+2      	; 0x364 <.L33>

00000362 <.L30>:
		tmp = buf[next];
		buf[next] = FRAME_BYTE;
		next += tmp;
	}
	return next;
}
 362:	08 95       	ret

00000364 <.L33>:
		tmp = buf[next];
 364:	df 01       	movw	r26, r30
 366:	a8 0f       	add	r26, r24
 368:	b1 1d       	adc	r27, r1

0000036a <.Loc.131>:
 36a:	9c 91       	ld	r25, X

0000036c <.Loc.132>:
		buf[next] = FRAME_BYTE;
 36c:	1c 92       	st	X, r1

0000036e <.Loc.134>:
		next += tmp;
 36e:	89 0f       	add	r24, r25

00000370 <.Loc.136>:
 370:	f4 cf       	rjmp	.-24     	; 0x35a <.L31>

00000372 <simpleserial_addcmd>:
    simpleserial_addcmd('w', 0, ss_get_commands);
}

int simpleserial_addcmd(char c, unsigned int len, uint8_t (*fp)(uint8_t, uint8_t, uint8_t, uint8_t*))
{
	if(num_commands >= MAX_SS_CMDS) {
 372:	20 91 50 20 	lds	r18, 0x2050	; 0x802050 <num_commands>
 376:	30 91 51 20 	lds	r19, 0x2051	; 0x802051 <num_commands+0x1>

0000037a <.Loc.140>:
 37a:	20 31       	cpi	r18, 0x10	; 16
 37c:	31 05       	cpc	r19, r1
 37e:	34 f0       	brlt	.+12     	; 0x38c <.L36>

00000380 <.Loc.141>:
		putch('a');
 380:	81 e6       	ldi	r24, 0x61	; 97

00000382 <.L39>:
		return 1;
	}

	if(len >= MAX_SS_LEN) {
		putch('b');
 382:	0e 94 85 03 	call	0x70a	; 0x70a <output_ch_0>

00000386 <.LVL56>:
		return 1;
 386:	81 e0       	ldi	r24, 0x01	; 1
 388:	90 e0       	ldi	r25, 0x00	; 0
 38a:	08 95       	ret

0000038c <.L36>:
	if(len >= MAX_SS_LEN) {
 38c:	6f 3f       	cpi	r22, 0xFF	; 255
 38e:	71 05       	cpc	r23, r1
 390:	19 f0       	breq	.+6      	; 0x398 <.L38>
 392:	10 f0       	brcs	.+4      	; 0x398 <.L38>

00000394 <.Loc.147>:
		putch('b');
 394:	82 e6       	ldi	r24, 0x62	; 98

00000396 <.LVL58>:
 396:	f5 cf       	rjmp	.-22     	; 0x382 <.L39>

00000398 <.L38>:
	}

	commands[num_commands].c   = c;
 398:	95 e0       	ldi	r25, 0x05	; 5
 39a:	92 9f       	mul	r25, r18
 39c:	f0 01       	movw	r30, r0
 39e:	93 9f       	mul	r25, r19
 3a0:	f0 0d       	add	r31, r0
 3a2:	11 24       	eor	r1, r1
 3a4:	e0 50       	subi	r30, 0x00	; 0
 3a6:	f0 4e       	sbci	r31, 0xE0	; 224
 3a8:	80 83       	st	Z, r24

000003aa <.Loc.151>:
	commands[num_commands].len = len;
 3aa:	61 83       	std	Z+1, r22	; 0x01
 3ac:	72 83       	std	Z+2, r23	; 0x02

000003ae <.Loc.153>:
	commands[num_commands].fp  = fp;
 3ae:	43 83       	std	Z+3, r20	; 0x03
 3b0:	54 83       	std	Z+4, r21	; 0x04

000003b2 <.Loc.155>:
	num_commands++;
 3b2:	2f 5f       	subi	r18, 0xFF	; 255
 3b4:	3f 4f       	sbci	r19, 0xFF	; 255
 3b6:	20 93 50 20 	sts	0x2050, r18	; 0x802050 <num_commands>
 3ba:	30 93 51 20 	sts	0x2051, r19	; 0x802051 <num_commands+0x1>

000003be <.Loc.157>:

	return 0;
 3be:	90 e0       	ldi	r25, 0x00	; 0
 3c0:	80 e0       	ldi	r24, 0x00	; 0

000003c2 <.LVL60>:
}
 3c2:	08 95       	ret

000003c4 <simpleserial_init>:
	simpleserial_addcmd('v', 0, check_version);
 3c4:	48 e4       	ldi	r20, 0x48	; 72
 3c6:	52 e0       	ldi	r21, 0x02	; 2
 3c8:	70 e0       	ldi	r23, 0x00	; 0
 3ca:	60 e0       	ldi	r22, 0x00	; 0
 3cc:	86 e7       	ldi	r24, 0x76	; 118
 3ce:	0e 94 b9 01 	call	0x372	; 0x372 <simpleserial_addcmd>

000003d2 <.LVL61>:
    simpleserial_addcmd('w', 0, ss_get_commands);
 3d2:	4b e5       	ldi	r20, 0x5B	; 91
 3d4:	52 e0       	ldi	r21, 0x02	; 2
 3d6:	70 e0       	ldi	r23, 0x00	; 0
 3d8:	60 e0       	ldi	r22, 0x00	; 0
 3da:	87 e7       	ldi	r24, 0x77	; 119
 3dc:	0c 94 b9 01 	jmp	0x372	; 0x372 <simpleserial_addcmd>

000003e0 <simpleserial_put>:
	simpleserial_put('e', 0x01, &err);
	return;
}

void simpleserial_put(char c, uint8_t size, uint8_t* output)
{
 3e0:	cf 92       	push	r12

000003e2 <.LCFI2>:
 3e2:	df 92       	push	r13

000003e4 <.LCFI3>:
 3e4:	ef 92       	push	r14

000003e6 <.LCFI4>:
 3e6:	ff 92       	push	r15

000003e8 <.LCFI5>:
 3e8:	0f 93       	push	r16

000003ea <.LCFI6>:
 3ea:	1f 93       	push	r17

000003ec <.LCFI7>:
 3ec:	cf 93       	push	r28

000003ee <.LCFI8>:
 3ee:	df 93       	push	r29

000003f0 <.LCFI9>:
 3f0:	cd b7       	in	r28, 0x3d	; 61
 3f2:	de b7       	in	r29, 0x3e	; 62

000003f4 <.LCFI10>:
 3f4:	da 95       	dec	r29

000003f6 <.LCFI11>:
 3f6:	cd bf       	out	0x3d, r28	; 61
 3f8:	de bf       	out	0x3e, r29	; 62
 3fa:	16 2f       	mov	r17, r22
 3fc:	fa 01       	movw	r30, r20

000003fe <.Loc.165>:
    if (!output) return;
 3fe:	30 97       	sbiw	r30, 0x00	; 0
 400:	c1 f1       	breq	.+112    	; 0x472 <.L41>

00000402 <.Loc.167>:
	uint8_t data_buf[MAX_SS_LEN];
	data_buf[0] = 0x00;
 402:	19 82       	std	Y+1, r1	; 0x01

00000404 <.Loc.170>:
	data_buf[1] = c;
 404:	8a 83       	std	Y+2, r24	; 0x02

00000406 <.Loc.172>:
	data_buf[2] = size;
 406:	6b 83       	std	Y+3, r22	; 0x03

00000408 <.LVL64>:
	int i = 0;
	for (; i < size; i++) {
 408:	de 01       	movw	r26, r28
 40a:	14 96       	adiw	r26, 0x04	; 4
 40c:	e6 2e       	mov	r14, r22
 40e:	f1 2c       	mov	r15, r1
 410:	ca 01       	movw	r24, r20

00000412 <.LVL65>:
 412:	8e 0d       	add	r24, r14
 414:	9f 1d       	adc	r25, r15
 416:	6d 01       	movw	r12, r26

00000418 <.L43>:
 418:	e8 17       	cp	r30, r24
 41a:	f9 07       	cpc	r31, r25
 41c:	b1 f5       	brne	.+108    	; 0x48a <.L44>

0000041e <.Loc.179>:
		data_buf[i + 3] = output[i];
	}
	data_buf[i + 3] = ss_crc(data_buf+1, size+2);
 41e:	62 e0       	ldi	r22, 0x02	; 2
 420:	61 0f       	add	r22, r17
 422:	ce 01       	movw	r24, r28
 424:	02 96       	adiw	r24, 0x02	; 2
 426:	0e 94 2b 01 	call	0x256	; 0x256 <ss_crc>

0000042a <.LVL67>:
 42a:	f6 01       	movw	r30, r12
 42c:	ee 0d       	add	r30, r14
 42e:	ff 1d       	adc	r31, r15
 430:	80 83       	st	Z, r24

00000432 <.Loc.182>:
	data_buf[i + 4] = 0x00;
 432:	84 e0       	ldi	r24, 0x04	; 4
 434:	e8 0e       	add	r14, r24
 436:	f1 1c       	adc	r15, r1

00000438 <.LVL68>:
 438:	e1 e0       	ldi	r30, 0x01	; 1
 43a:	f0 e0       	ldi	r31, 0x00	; 0
 43c:	ec 0f       	add	r30, r28
 43e:	fd 1f       	adc	r31, r29
 440:	ee 0d       	add	r30, r14
 442:	ff 1d       	adc	r31, r15
 444:	10 82       	st	Z, r1

00000446 <.Loc.185>:
	stuff_data(data_buf, i + 5);
 446:	65 e0       	ldi	r22, 0x05	; 5
 448:	61 0f       	add	r22, r17
 44a:	ce 01       	movw	r24, r28
 44c:	01 96       	adiw	r24, 0x01	; 1
 44e:	0e 94 94 01 	call	0x328	; 0x328 <stuff_data>

00000452 <.LBB6>:
	for (int i = 0; i < size + 5; i++) {
 452:	8e 01       	movw	r16, r28
 454:	0f 5f       	subi	r16, 0xFF	; 255
 456:	1f 4f       	sbci	r17, 0xFF	; 255

00000458 <.Loc.189>:
 458:	d1 2c       	mov	r13, r1
 45a:	c1 2c       	mov	r12, r1

0000045c <.L45>:
		putch(data_buf[i]);
 45c:	f8 01       	movw	r30, r16
 45e:	81 91       	ld	r24, Z+
 460:	8f 01       	movw	r16, r30
 462:	0e 94 85 03 	call	0x70a	; 0x70a <output_ch_0>

00000466 <.LVL71>:
	for (int i = 0; i < size + 5; i++) {
 466:	ff ef       	ldi	r31, 0xFF	; 255
 468:	cf 1a       	sub	r12, r31
 46a:	df 0a       	sbc	r13, r31

0000046c <.Loc.193>:
 46c:	ec 14       	cp	r14, r12
 46e:	fd 04       	cpc	r15, r13
 470:	ac f7       	brge	.-22     	; 0x45c <.L45>

00000472 <.L41>:
	}
}
 472:	d3 95       	inc	r29
 474:	cd bf       	out	0x3d, r28	; 61
 476:	de bf       	out	0x3e, r29	; 62
 478:	df 91       	pop	r29
 47a:	cf 91       	pop	r28
 47c:	1f 91       	pop	r17

0000047e <.LVL74>:
 47e:	0f 91       	pop	r16
 480:	ff 90       	pop	r15
 482:	ef 90       	pop	r14
 484:	df 90       	pop	r13
 486:	cf 90       	pop	r12
 488:	08 95       	ret

0000048a <.L44>:
		data_buf[i + 3] = output[i];
 48a:	21 91       	ld	r18, Z+

0000048c <.LVL76>:
 48c:	2d 93       	st	X+, r18

0000048e <.LVL77>:
	for (; i < size; i++) {
 48e:	c4 cf       	rjmp	.-120    	; 0x418 <.L43>

00000490 <check_version>:
{
 490:	cf 93       	push	r28

00000492 <.LCFI12>:
 492:	df 93       	push	r29

00000494 <.LCFI13>:
 494:	0f 92       	push	r0

00000496 <.LCFI14>:
 496:	cd b7       	in	r28, 0x3d	; 61
 498:	de b7       	in	r29, 0x3e	; 62

0000049a <.LCFI15>:
	uint8_t ver = SS_VER;
 49a:	83 e0       	ldi	r24, 0x03	; 3

0000049c <.LVL79>:
 49c:	89 83       	std	Y+1, r24	; 0x01

0000049e <.Loc.208>:
	simpleserial_put('r', 1, &ver);
 49e:	ae 01       	movw	r20, r28

000004a0 <.LVL80>:
 4a0:	4f 5f       	subi	r20, 0xFF	; 255
 4a2:	5f 4f       	sbci	r21, 0xFF	; 255
 4a4:	61 e0       	ldi	r22, 0x01	; 1

000004a6 <.LVL81>:
 4a6:	82 e7       	ldi	r24, 0x72	; 114
 4a8:	0e 94 f0 01 	call	0x3e0	; 0x3e0 <simpleserial_put>

000004ac <.LVL82>:
}
 4ac:	80 e0       	ldi	r24, 0x00	; 0
 4ae:	0f 90       	pop	r0
 4b0:	df 91       	pop	r29
 4b2:	cf 91       	pop	r28
 4b4:	08 95       	ret

000004b6 <ss_get_commands>:
{
 4b6:	cf 93       	push	r28

000004b8 <.LCFI16>:
 4b8:	df 93       	push	r29

000004ba <.LCFI17>:
 4ba:	cd b7       	in	r28, 0x3d	; 61
 4bc:	de b7       	in	r29, 0x3e	; 62

000004be <.LCFI18>:
 4be:	60 97       	sbiw	r28, 0x10	; 16

000004c0 <.LCFI19>:
 4c0:	cd bf       	out	0x3d, r28	; 61
 4c2:	de bf       	out	0x3e, r29	; 62

000004c4 <.LBB7>:
    for (uint8_t i = 0; i < (num_commands & 0xFF); i++) {
 4c4:	60 91 50 20 	lds	r22, 0x2050	; 0x802050 <num_commands>
 4c8:	70 91 51 20 	lds	r23, 0x2051	; 0x802051 <num_commands+0x1>

000004cc <.LVL85>:
 4cc:	ab 01       	movw	r20, r22

000004ce <.LVL86>:
 4ce:	55 27       	eor	r21, r21

000004d0 <.Loc.221>:
 4d0:	20 e0       	ldi	r18, 0x00	; 0

000004d2 <.LVL87>:
        cmd_chars[i] = commands[i].c;
 4d2:	35 e0       	ldi	r19, 0x05	; 5

000004d4 <.L50>:
    for (uint8_t i = 0; i < (num_commands & 0xFF); i++) {
 4d4:	82 2f       	mov	r24, r18
 4d6:	90 e0       	ldi	r25, 0x00	; 0

000004d8 <.Loc.225>:
 4d8:	84 17       	cp	r24, r20
 4da:	95 07       	cpc	r25, r21
 4dc:	6c f0       	brlt	.+26     	; 0x4f8 <.L51>

000004de <.LBE7>:
    simpleserial_put('r', num_commands & 0xFF, (void *)cmd_chars);
 4de:	ae 01       	movw	r20, r28
 4e0:	4f 5f       	subi	r20, 0xFF	; 255
 4e2:	5f 4f       	sbci	r21, 0xFF	; 255
 4e4:	82 e7       	ldi	r24, 0x72	; 114
 4e6:	0e 94 f0 01 	call	0x3e0	; 0x3e0 <simpleserial_put>

000004ea <.LVL89>:
}
 4ea:	80 e0       	ldi	r24, 0x00	; 0
 4ec:	60 96       	adiw	r28, 0x10	; 16
 4ee:	cd bf       	out	0x3d, r28	; 61
 4f0:	de bf       	out	0x3e, r29	; 62
 4f2:	df 91       	pop	r29
 4f4:	cf 91       	pop	r28
 4f6:	08 95       	ret

000004f8 <.L51>:
        cmd_chars[i] = commands[i].c;
 4f8:	a1 e0       	ldi	r26, 0x01	; 1
 4fa:	b0 e0       	ldi	r27, 0x00	; 0
 4fc:	ac 0f       	add	r26, r28
 4fe:	bd 1f       	adc	r27, r29
 500:	a8 0f       	add	r26, r24
 502:	b9 1f       	adc	r27, r25

00000504 <.Loc.231>:
 504:	38 9f       	mul	r19, r24
 506:	f0 01       	movw	r30, r0
 508:	39 9f       	mul	r19, r25
 50a:	f0 0d       	add	r31, r0
 50c:	11 24       	eor	r1, r1
 50e:	e0 50       	subi	r30, 0x00	; 0
 510:	f0 4e       	sbci	r31, 0xE0	; 224

00000512 <.Loc.232>:
 512:	80 81       	ld	r24, Z
 514:	8c 93       	st	X, r24

00000516 <.Loc.233>:
    for (uint8_t i = 0; i < (num_commands & 0xFF); i++) {
 516:	2f 5f       	subi	r18, 0xFF	; 255

00000518 <.Loc.235>:
 518:	dd cf       	rjmp	.-70     	; 0x4d4 <.L50>

0000051a <simpleserial_get>:
{
 51a:	5f 92       	push	r5

0000051c <.LCFI20>:
 51c:	6f 92       	push	r6

0000051e <.LCFI21>:
 51e:	7f 92       	push	r7

00000520 <.LCFI22>:
 520:	8f 92       	push	r8

00000522 <.LCFI23>:
 522:	9f 92       	push	r9

00000524 <.LCFI24>:
 524:	af 92       	push	r10

00000526 <.LCFI25>:
 526:	bf 92       	push	r11

00000528 <.LCFI26>:
 528:	cf 92       	push	r12

0000052a <.LCFI27>:
 52a:	df 92       	push	r13

0000052c <.LCFI28>:
 52c:	ef 92       	push	r14

0000052e <.LCFI29>:
 52e:	ff 92       	push	r15

00000530 <.LCFI30>:
 530:	0f 93       	push	r16

00000532 <.LCFI31>:
 532:	1f 93       	push	r17

00000534 <.LCFI32>:
 534:	cf 93       	push	r28

00000536 <.LCFI33>:
 536:	df 93       	push	r29

00000538 <.LCFI34>:
 538:	cd b7       	in	r28, 0x3d	; 61
 53a:	de b7       	in	r29, 0x3e	; 62

0000053c <.LCFI35>:
 53c:	c1 50       	subi	r28, 0x01	; 1
 53e:	d1 40       	sbci	r29, 0x01	; 1

00000540 <.LCFI36>:
 540:	cd bf       	out	0x3d, r28	; 61
 542:	de bf       	out	0x3e, r29	; 62

00000544 <.Loc.237>:
	uint8_t err = 0;
 544:	cf 5f       	subi	r28, 0xFF	; 255
 546:	de 4f       	sbci	r29, 0xFE	; 254
 548:	18 82       	st	Y, r1
 54a:	c1 50       	subi	r28, 0x01	; 1
 54c:	d1 40       	sbci	r29, 0x01	; 1

0000054e <.LBB9>:
	for (int i = 0; i < 4; i++) {
 54e:	8e 01       	movw	r16, r28
 550:	0f 5f       	subi	r16, 0xFF	; 255
 552:	1f 4f       	sbci	r17, 0xFF	; 255
 554:	5e 01       	movw	r10, r28
 556:	85 e0       	ldi	r24, 0x05	; 5
 558:	a8 0e       	add	r10, r24
 55a:	b1 1c       	adc	r11, r1
 55c:	68 01       	movw	r12, r16

0000055e <.L55>:
		data_buf[i] = getch(); //PTR, cmd, scmd, len
 55e:	0e 94 7e 03 	call	0x6fc	; 0x6fc <input_ch_0>

00000562 <.LVL94>:
 562:	f8 01       	movw	r30, r16
 564:	81 93       	st	Z+, r24
 566:	8f 01       	movw	r16, r30

00000568 <.Loc.246>:
		if (data_buf[i] == FRAME_BYTE) {
 568:	81 11       	cpse	r24, r1
 56a:	21 c0       	rjmp	.+66     	; 0x5ae <.L53>

0000056c <.L60>:
			err = SS_ERR_FRAME_BYTE;
 56c:	85 e0       	ldi	r24, 0x05	; 5

0000056e <.L69>:
	err = commands[c].fp(data_buf[1], data_buf[2], data_buf[3], data_buf+4);
 56e:	cf 5f       	subi	r28, 0xFF	; 255
 570:	de 4f       	sbci	r29, 0xFE	; 254
 572:	88 83       	st	Y, r24
 574:	c1 50       	subi	r28, 0x01	; 1
 576:	d1 40       	sbci	r29, 0x01	; 1

00000578 <.L54>:
	simpleserial_put('e', 0x01, &err);
 578:	ae 01       	movw	r20, r28
 57a:	4f 5f       	subi	r20, 0xFF	; 255
 57c:	5e 4f       	sbci	r21, 0xFE	; 254
 57e:	61 e0       	ldi	r22, 0x01	; 1
 580:	85 e6       	ldi	r24, 0x65	; 101
 582:	0e 94 f0 01 	call	0x3e0	; 0x3e0 <simpleserial_put>

00000586 <.LVL95>:
}
 586:	cf 5f       	subi	r28, 0xFF	; 255
 588:	de 4f       	sbci	r29, 0xFE	; 254
 58a:	cd bf       	out	0x3d, r28	; 61
 58c:	de bf       	out	0x3e, r29	; 62
 58e:	df 91       	pop	r29
 590:	cf 91       	pop	r28
 592:	1f 91       	pop	r17
 594:	0f 91       	pop	r16
 596:	ff 90       	pop	r15
 598:	ef 90       	pop	r14
 59a:	df 90       	pop	r13
 59c:	cf 90       	pop	r12
 59e:	bf 90       	pop	r11
 5a0:	af 90       	pop	r10
 5a2:	9f 90       	pop	r9
 5a4:	8f 90       	pop	r8
 5a6:	7f 90       	pop	r7
 5a8:	6f 90       	pop	r6
 5aa:	5f 90       	pop	r5
 5ac:	08 95       	ret

000005ae <.L53>:
	for (int i = 0; i < 4; i++) {
 5ae:	ae 16       	cp	r10, r30
 5b0:	bf 06       	cpc	r11, r31
 5b2:	a9 f6       	brne	.-86     	; 0x55e <.L55>

000005b4 <.LBE10>:
	uint8_t next_frame = unstuff_data(data_buf, 4);
 5b4:	64 e0       	ldi	r22, 0x04	; 4
 5b6:	c6 01       	movw	r24, r12
 5b8:	0e 94 a9 01 	call	0x352	; 0x352 <unstuff_data>

000005bc <.LVL96>:
 5bc:	58 2e       	mov	r5, r24

000005be <.LVL97>:
	for(c = 0; c < num_commands; c++)
 5be:	20 91 50 20 	lds	r18, 0x2050	; 0x802050 <num_commands>
 5c2:	30 91 51 20 	lds	r19, 0x2051	; 0x802051 <num_commands+0x1>

000005c6 <.Loc.262>:
		if(commands[c].c == data_buf[1])
 5c6:	9a 81       	ldd	r25, Y+2	; 0x02

000005c8 <.Loc.263>:
	for(c = 0; c < num_commands; c++)
 5c8:	80 e0       	ldi	r24, 0x00	; 0

000005ca <.Loc.264>:
		if(commands[c].c == data_buf[1])
 5ca:	45 e0       	ldi	r20, 0x05	; 5

000005cc <.L56>:
	for(c = 0; c < num_commands; c++)
 5cc:	e8 2e       	mov	r14, r24
 5ce:	f1 2c       	mov	r15, r1

000005d0 <.Loc.267>:
 5d0:	e2 16       	cp	r14, r18
 5d2:	f3 06       	cpc	r15, r19
 5d4:	8c f0       	brlt	.+34     	; 0x5f8 <.L58>

000005d6 <.Loc.268>:
		err = SS_ERR_CMD;
 5d6:	81 e0       	ldi	r24, 0x01	; 1

000005d8 <.LVL99>:
	if (c == num_commands) {
 5d8:	e2 16       	cp	r14, r18
 5da:	f3 06       	cpc	r15, r19
 5dc:	41 f2       	breq	.-112    	; 0x56e <.L69>

000005de <.L57>:
	if ((data_buf[3] + 5) < next_frame) {
 5de:	8c 81       	ldd	r24, Y+4	; 0x04
 5e0:	90 e0       	ldi	r25, 0x00	; 0

000005e2 <.Loc.273>:
 5e2:	05 96       	adiw	r24, 0x05	; 5

000005e4 <.Loc.274>:
 5e4:	85 2c       	mov	r8, r5
 5e6:	91 2c       	mov	r9, r1

000005e8 <.Loc.275>:
	int i = 4;
 5e8:	04 e0       	ldi	r16, 0x04	; 4
 5ea:	10 e0       	ldi	r17, 0x00	; 0

000005ec <.Loc.276>:
	if ((data_buf[3] + 5) < next_frame) {
 5ec:	58 16       	cp	r5, r24
 5ee:	19 06       	cpc	r1, r25
 5f0:	79 f0       	breq	.+30     	; 0x610 <.L59>
 5f2:	74 f0       	brlt	.+28     	; 0x610 <.L59>

000005f4 <.L61>:
		err = SS_ERR_LEN;
 5f4:	84 e0       	ldi	r24, 0x04	; 4
 5f6:	bb cf       	rjmp	.-138    	; 0x56e <.L69>

000005f8 <.L58>:
		if(commands[c].c == data_buf[1])
 5f8:	4e 9d       	mul	r20, r14
 5fa:	f0 01       	movw	r30, r0
 5fc:	4f 9d       	mul	r20, r15
 5fe:	f0 0d       	add	r31, r0
 600:	11 24       	eor	r1, r1
 602:	e0 50       	subi	r30, 0x00	; 0
 604:	f0 4e       	sbci	r31, 0xE0	; 224

00000606 <.Loc.281>:
 606:	50 81       	ld	r21, Z
 608:	59 17       	cp	r21, r25
 60a:	49 f3       	breq	.-46     	; 0x5de <.L57>

0000060c <.Loc.282>:
	for(c = 0; c < num_commands; c++)
 60c:	8f 5f       	subi	r24, 0xFF	; 255

0000060e <.LVL100>:
 60e:	de cf       	rjmp	.-68     	; 0x5cc <.L56>

00000610 <.L59>:
		data_buf[i] = getch();
 610:	0e 94 7e 03 	call	0x6fc	; 0x6fc <input_ch_0>

00000614 <.LVL102>:
 614:	36 01       	movw	r6, r12
 616:	60 0e       	add	r6, r16
 618:	71 1e       	adc	r7, r17
 61a:	f3 01       	movw	r30, r6
 61c:	80 83       	st	Z, r24

0000061e <.Loc.288>:
		if (data_buf[i] == FRAME_BYTE) {
 61e:	88 23       	and	r24, r24
 620:	09 f4       	brne	.+2      	; 0x624 <.Loc.290>

00000622 <L0^A>:
 622:	a4 cf       	rjmp	.-184    	; 0x56c <.L60>

00000624 <.Loc.290>:
	for (; i < data_buf[3] + 5; i++) {
 624:	0f 5f       	subi	r16, 0xFF	; 255
 626:	1f 4f       	sbci	r17, 0xFF	; 255

00000628 <.Loc.292>:
 628:	8c 81       	ldd	r24, Y+4	; 0x04
 62a:	90 e0       	ldi	r25, 0x00	; 0

0000062c <.Loc.294>:
 62c:	04 96       	adiw	r24, 0x04	; 4

0000062e <.Loc.295>:
 62e:	80 17       	cp	r24, r16
 630:	91 07       	cpc	r25, r17
 632:	74 f7       	brge	.-36     	; 0x610 <.L59>

00000634 <.Loc.296>:
	data_buf[i] = getch();
 634:	0e 94 7e 03 	call	0x6fc	; 0x6fc <input_ch_0>

00000638 <.LVL104>:
 638:	f6 01       	movw	r30, r12
 63a:	e0 0f       	add	r30, r16
 63c:	f1 1f       	adc	r31, r17
 63e:	80 83       	st	Z, r24

00000640 <.Loc.299>:
	if (data_buf[i] != FRAME_BYTE) {
 640:	81 11       	cpse	r24, r1
 642:	d8 cf       	rjmp	.-80     	; 0x5f4 <.L61>

00000644 <.Loc.301>:
	unstuff_data(data_buf + next_frame, i - next_frame + 1);
 644:	60 2f       	mov	r22, r16
 646:	65 19       	sub	r22, r5
 648:	6f 5f       	subi	r22, 0xFF	; 255
 64a:	c6 01       	movw	r24, r12
 64c:	88 0d       	add	r24, r8
 64e:	99 1d       	adc	r25, r9
 650:	0e 94 a9 01 	call	0x352	; 0x352 <unstuff_data>

00000654 <.LVL105>:
	uint8_t crc = ss_crc(data_buf+1, i-2);
 654:	6e ef       	ldi	r22, 0xFE	; 254
 656:	60 0f       	add	r22, r16
 658:	ce 01       	movw	r24, r28
 65a:	02 96       	adiw	r24, 0x02	; 2
 65c:	0e 94 2b 01 	call	0x256	; 0x256 <ss_crc>

00000660 <.LVL106>:
	if (crc != data_buf[i-1]) {
 660:	f3 01       	movw	r30, r6
 662:	90 81       	ld	r25, Z
 664:	98 17       	cp	r25, r24
 666:	11 f0       	breq	.+4      	; 0x66c <.L62>

00000668 <.Loc.306>:
		err = SS_ERR_CRC;
 668:	82 e0       	ldi	r24, 0x02	; 2

0000066a <.LVL107>:
 66a:	81 cf       	rjmp	.-254    	; 0x56e <.L69>

0000066c <.L62>:
	err = commands[c].fp(data_buf[1], data_buf[2], data_buf[3], data_buf+4);
 66c:	85 e0       	ldi	r24, 0x05	; 5

0000066e <.LVL109>:
 66e:	8e 9d       	mul	r24, r14
 670:	f0 01       	movw	r30, r0
 672:	8f 9d       	mul	r24, r15
 674:	f0 0d       	add	r31, r0
 676:	11 24       	eor	r1, r1
 678:	e0 50       	subi	r30, 0x00	; 0
 67a:	f0 4e       	sbci	r31, 0xE0	; 224

0000067c <.Loc.312>:
 67c:	03 80       	ldd	r0, Z+3	; 0x03
 67e:	f4 81       	ldd	r31, Z+4	; 0x04
 680:	e0 2d       	mov	r30, r0
 682:	95 01       	movw	r18, r10
 684:	4c 81       	ldd	r20, Y+4	; 0x04
 686:	6b 81       	ldd	r22, Y+3	; 0x03
 688:	8a 81       	ldd	r24, Y+2	; 0x02
 68a:	19 95       	eicall

0000068c <.LVL110>:
 68c:	70 cf       	rjmp	.-288    	; 0x56e <.L69>

0000068e <led_ok>:

#include "hal.h"

__attribute__((weak)) void led_ok(unsigned int status)
{
}
 68e:	08 95       	ret

00000690 <led_error>:
 690:	08 95       	ret

00000692 <init_uart0>:
   )
   {
/* This PORT setting is only valid to USARTC0 if other USARTs is used a
	 * different PORT and/or pins is used. */
	/* PIN3 (TXD0) as output. */
	PORTC.DIRSET = PIN3_bm;
 692:	e0 e4       	ldi	r30, 0x40	; 64
 694:	f6 e0       	ldi	r31, 0x06	; 6
 696:	88 e0       	ldi	r24, 0x08	; 8
 698:	81 83       	std	Z+1, r24	; 0x01

0000069a <.Loc.3>:

	/* PC2 (RXD0) as input. */
	PORTC.DIRCLR = PIN2_bm;
 69a:	84 e0       	ldi	r24, 0x04	; 4
 69c:	82 83       	std	Z+2, r24	; 0x02

0000069e <.Loc.5>:

	/* USARTC0, 8 Data bits, No Parity, 1 Stop bit. */
	USART_Format_Set(&USART, USART_CHSIZE_8BIT_gc, USART_PMODE_DISABLED_gc, false);
 69e:	e0 ea       	ldi	r30, 0xA0	; 160
 6a0:	f8 e0       	ldi	r31, 0x08	; 8
 6a2:	83 e0       	ldi	r24, 0x03	; 3
 6a4:	85 83       	std	Z+5, r24	; 0x05

000006a6 <.Loc.6>:
	 *
	 * Baudrate select = (1/(16*(((I/O clock frequency)/Baudrate)-1)
	 *                 = 12
	 */
	#if SS_VER==SS_VER_2_1
	USART_Baudrate_Set(&USART, 1, 0);
 6a6:	81 e0       	ldi	r24, 0x01	; 1
 6a8:	86 83       	std	Z+6, r24	; 0x06

000006aa <.Loc.7>:
 6aa:	17 82       	std	Z+7, r1	; 0x07

000006ac <.Loc.8>:
	#else
	USART_Baudrate_Set(&USART, 11, 0);
	#endif

	/* Enable both RX and TX. */
	USART_Rx_Enable(&USART);
 6ac:	84 81       	ldd	r24, Z+4	; 0x04
 6ae:	80 61       	ori	r24, 0x10	; 16
 6b0:	84 83       	std	Z+4, r24	; 0x04

000006b2 <.Loc.9>:
	USART_Tx_Enable(&USART);
 6b2:	84 81       	ldd	r24, Z+4	; 0x04
 6b4:	88 60       	ori	r24, 0x08	; 8
 6b6:	84 83       	std	Z+4, r24	; 0x04

000006b8 <.Loc.10>:
   }
 6b8:	08 95       	ret

000006ba <input_ch_w_timeout_0>:
unsigned char									input_ch_w_timeout_0
	(
   char *					 	data,
   volatile unsigned int				timeout
   )
   {
 6ba:	cf 93       	push	r28

000006bc <.LCFI0>:
 6bc:	df 93       	push	r29

000006be <.LCFI1>:
 6be:	0f 92       	push	r0
 6c0:	0f 92       	push	r0

000006c2 <.LCFI2>:
 6c2:	cd b7       	in	r28, 0x3d	; 61
 6c4:	de b7       	in	r29, 0x3e	; 62

000006c6 <.LCFI3>:
 6c6:	fc 01       	movw	r30, r24
 6c8:	69 83       	std	Y+1, r22	; 0x01
 6ca:	7a 83       	std	Y+2, r23	; 0x02

000006cc <.LVL1>:
   unsigned int				timeout_counter = 0;
 6cc:	90 e0       	ldi	r25, 0x00	; 0
 6ce:	80 e0       	ldi	r24, 0x00	; 0

000006d0 <.L3>:

   
   //check if a byte has been recieved or if the timeout has been excedded
   while (timeout_counter != timeout)
 6d0:	29 81       	ldd	r18, Y+1	; 0x01
 6d2:	3a 81       	ldd	r19, Y+2	; 0x02

000006d4 <.Loc.18>:
 6d4:	28 17       	cp	r18, r24
 6d6:	39 07       	cpc	r19, r25
 6d8:	11 f4       	brne	.+4      	; 0x6de <.L6>

000006da <.Loc.19>:
			return BYTE_REC;
			}
		timeout_counter++;
		}
		
	return TIMEOUT;
 6da:	80 e0       	ldi	r24, 0x00	; 0

000006dc <.LVL3>:
 6dc:	08 c0       	rjmp	.+16     	; 0x6ee <.L2>

000006de <.L6>:
		if (USART_IsRXComplete(&USART))
 6de:	20 91 a1 08 	lds	r18, 0x08A1	; 0x8008a1 <__TEXT_REGION_LENGTH__+0x7008a1>

000006e2 <.Loc.23>:
 6e2:	27 ff       	sbrs	r18, 7
 6e4:	09 c0       	rjmp	.+18     	; 0x6f8 <.L4>

000006e6 <.Loc.24>:
			*data = USART_GetChar(&USART);
 6e6:	80 91 a0 08 	lds	r24, 0x08A0	; 0x8008a0 <__TEXT_REGION_LENGTH__+0x7008a0>

000006ea <.LVL5>:
 6ea:	80 83       	st	Z, r24

000006ec <.Loc.27>:
			return BYTE_REC;
 6ec:	81 e0       	ldi	r24, 0x01	; 1

000006ee <.L2>:
	}
 6ee:	0f 90       	pop	r0
 6f0:	0f 90       	pop	r0
 6f2:	df 91       	pop	r29
 6f4:	cf 91       	pop	r28
 6f6:	08 95       	ret

000006f8 <.L4>:
		timeout_counter++;
 6f8:	01 96       	adiw	r24, 0x01	; 1

000006fa <.Loc.32>:
 6fa:	ea cf       	rjmp	.-44     	; 0x6d0 <.L3>

000006fc <input_ch_0>:
	(
   void
   )
   {
   //check if a byte has been recieved or if the timeout has been excedded
   while (!USART_IsRXComplete(&USART))
 6fc:	80 91 a1 08 	lds	r24, 0x08A1	; 0x8008a1 <__TEXT_REGION_LENGTH__+0x7008a1>

00000700 <.Loc.36>:
 700:	87 ff       	sbrs	r24, 7
 702:	fc cf       	rjmp	.-8      	; 0x6fc <input_ch_0>

00000704 <.Loc.37>:
		{
		continue;		
		}		
	return USART_GetChar(&USART);;
 704:	80 91 a0 08 	lds	r24, 0x08A0	; 0x8008a0 <__TEXT_REGION_LENGTH__+0x7008a0>

00000708 <.Loc.39>:
	}
 708:	08 95       	ret

0000070a <output_ch_0>:
void												output_ch_0
	(
	char							data
	)
	{
	while(!USART_IsTXDataRegisterEmpty(&USART));
 70a:	90 91 a1 08 	lds	r25, 0x08A1	; 0x8008a1 <__TEXT_REGION_LENGTH__+0x7008a1>

0000070e <.Loc.45>:
 70e:	95 ff       	sbrs	r25, 5
 710:	fc cf       	rjmp	.-8      	; 0x70a <output_ch_0>

00000712 <.Loc.46>:
	USART_PutChar(&USART, data);
 712:	80 93 a0 08 	sts	0x08A0, r24	; 0x8008a0 <__TEXT_REGION_LENGTH__+0x7008a0>

00000716 <.Loc.47>:
	return;
 716:	08 95       	ret

00000718 <USART_InterruptDriver_Initialize>:
 *  \param dreIntLevel          Data register empty interrupt level.
 */
void USART_InterruptDriver_Initialize(USART_data_t * usart_data,
                                      USART_t * usart,
                                      USART_DREINTLVL_t dreIntLevel)
{
 718:	fc 01       	movw	r30, r24

0000071a <.Loc.2>:
	usart_data->usart = usart;
 71a:	60 83       	st	Z, r22
 71c:	71 83       	std	Z+1, r23	; 0x01

0000071e <.Loc.4>:
	usart_data->dreIntLevel = dreIntLevel;
 71e:	42 83       	std	Z+2, r20	; 0x02

00000720 <.Loc.6>:

	usart_data->buffer.RX_Tail = 0;
 720:	14 86       	std	Z+12, r1	; 0x0c

00000722 <.Loc.8>:
	usart_data->buffer.RX_Head = 0;
 722:	13 86       	std	Z+11, r1	; 0x0b

00000724 <.Loc.10>:
	usart_data->buffer.TX_Tail = 0;
 724:	16 86       	std	Z+14, r1	; 0x0e

00000726 <.Loc.12>:
	usart_data->buffer.TX_Head = 0;
 726:	15 86       	std	Z+13, r1	; 0x0d

00000728 <.Loc.14>:
}
 728:	08 95       	ret

0000072a <USART_InterruptDriver_DreInterruptLevel_Set>:
 *  \param dreIntLevel        Interrupt level of the DRE interrupt.
 */
void USART_InterruptDriver_DreInterruptLevel_Set(USART_data_t * usart_data,
                                                 USART_DREINTLVL_t dreIntLevel)
{
	usart_data->dreIntLevel = dreIntLevel;
 72a:	fc 01       	movw	r30, r24
 72c:	62 83       	std	Z+2, r22	; 0x02

0000072e <.Loc.18>:
}
 72e:	08 95       	ret

00000730 <USART_TXBuffer_FreeSpace>:
 *
 *  \retval true      There is data in the receive buffer.
 *  \retval false     The receive buffer is empty.
 */
bool USART_TXBuffer_FreeSpace(USART_data_t * usart_data)
{
 730:	fc 01       	movw	r30, r24

00000732 <.Loc.21>:
	/* Make copies to make sure that volatile access is specified. */
	uint8_t tempHead = (usart_data->buffer.TX_Head + 1) & USART_TX_BUFFER_MASK;
 732:	95 85       	ldd	r25, Z+13	; 0x0d

00000734 <.LVL3>:
	uint8_t tempTail = usart_data->buffer.TX_Tail;
 734:	26 85       	ldd	r18, Z+14	; 0x0e

00000736 <.LVL4>:
	uint8_t tempHead = (usart_data->buffer.TX_Head + 1) & USART_TX_BUFFER_MASK;
 736:	9f 5f       	subi	r25, 0xFF	; 255

00000738 <.LVL5>:
 738:	93 70       	andi	r25, 0x03	; 3

0000073a <.LVL6>:

	/* There are data left in the buffer unless Head and Tail are equal. */
	return (tempHead != tempTail);
 73a:	81 e0       	ldi	r24, 0x01	; 1

0000073c <.LVL7>:
 73c:	92 13       	cpse	r25, r18
 73e:	01 c0       	rjmp	.+2      	; 0x742 <.L4>
 740:	80 e0       	ldi	r24, 0x00	; 0

00000742 <.L4>:
}
 742:	08 95       	ret

00000744 <USART_TXBuffer_PutByte>:
 *
 *  \param usart_data The USART_data_t struct instance.
 *  \param data       The data to send.
 */
bool USART_TXBuffer_PutByte(USART_data_t * usart_data, uint8_t data)
{
 744:	1f 93       	push	r17

00000746 <.LCFI0>:
 746:	cf 93       	push	r28

00000748 <.LCFI1>:
 748:	df 93       	push	r29

0000074a <.LCFI2>:
 74a:	ec 01       	movw	r28, r24
 74c:	16 2f       	mov	r17, r22

0000074e <.LVL9>:
	uint8_t tempTX_Head;
	bool TXBuffer_FreeSpace;
	USART_Buffer_t * TXbufPtr;

	TXbufPtr = &usart_data->buffer;
	TXBuffer_FreeSpace = USART_TXBuffer_FreeSpace(usart_data);
 74e:	0e 94 98 03 	call	0x730	; 0x730 <USART_TXBuffer_FreeSpace>

00000752 <.LVL10>:


	if(TXBuffer_FreeSpace)
 752:	88 23       	and	r24, r24
 754:	79 f0       	breq	.+30     	; 0x774 <.L5>

00000756 <.Loc.42>:
	{
	  	tempTX_Head = TXbufPtr->TX_Head;
 756:	9d 85       	ldd	r25, Y+13	; 0x0d

00000758 <.LVL11>:
	  	TXbufPtr->TX[tempTX_Head]= data;
 758:	fe 01       	movw	r30, r28
 75a:	e9 0f       	add	r30, r25
 75c:	f1 1d       	adc	r31, r1
 75e:	17 83       	std	Z+7, r17	; 0x07

00000760 <.Loc.46>:
		/* Advance buffer head. */
		TXbufPtr->TX_Head = (tempTX_Head + 1) & USART_TX_BUFFER_MASK;
 760:	9f 5f       	subi	r25, 0xFF	; 255

00000762 <.LVL12>:
 762:	93 70       	andi	r25, 0x03	; 3

00000764 <.LVL13>:
 764:	9d 87       	std	Y+13, r25	; 0x0d

00000766 <.Loc.50>:

		/* Enable DRE interrupt. */
		tempCTRLA = usart_data->usart->CTRLA;
 766:	e8 81       	ld	r30, Y
 768:	f9 81       	ldd	r31, Y+1	; 0x01

0000076a <.Loc.52>:
 76a:	93 81       	ldd	r25, Z+3	; 0x03

0000076c <.LVL14>:
		tempCTRLA = (tempCTRLA & ~USART_DREINTLVL_gm) | usart_data->dreIntLevel;
 76c:	9c 7f       	andi	r25, 0xFC	; 252

0000076e <.LVL15>:
 76e:	2a 81       	ldd	r18, Y+2	; 0x02
 770:	92 2b       	or	r25, r18

00000772 <.LVL16>:
		usart_data->usart->CTRLA = tempCTRLA;
 772:	93 83       	std	Z+3, r25	; 0x03

00000774 <.L5>:
	}
	return TXBuffer_FreeSpace;
}
 774:	df 91       	pop	r29
 776:	cf 91       	pop	r28

00000778 <.LVL18>:
 778:	1f 91       	pop	r17

0000077a <.LVL19>:
 77a:	08 95       	ret

0000077c <USART_RXBufferData_Available>:
 *
 *  \retval true      There is data in the receive buffer.
 *  \retval false     The receive buffer is empty.
 */
bool USART_RXBufferData_Available(USART_data_t * usart_data)
{
 77c:	fc 01       	movw	r30, r24

0000077e <.Loc.64>:
	/* Make copies to make sure that volatile access is specified. */
	uint8_t tempHead = usart_data->buffer.RX_Head;
 77e:	23 85       	ldd	r18, Z+11	; 0x0b

00000780 <.LVL21>:
	uint8_t tempTail = usart_data->buffer.RX_Tail;
 780:	94 85       	ldd	r25, Z+12	; 0x0c

00000782 <.LVL22>:

	/* There are data left in the buffer unless Head and Tail are equal. */
	return (tempHead != tempTail);
 782:	81 e0       	ldi	r24, 0x01	; 1

00000784 <.LVL23>:
 784:	29 13       	cpse	r18, r25
 786:	01 c0       	rjmp	.+2      	; 0x78a <.L11>
 788:	80 e0       	ldi	r24, 0x00	; 0

0000078a <.L11>:
}
 78a:	08 95       	ret

0000078c <USART_RXBuffer_GetByte>:
 *  \param usart_data       The USART_data_t struct instance.
 *
 *  \return         Received data.
 */
uint8_t USART_RXBuffer_GetByte(USART_data_t * usart_data)
{
 78c:	fc 01       	movw	r30, r24

0000078e <.LVL25>:
	USART_Buffer_t * bufPtr;
	uint8_t ans;

	bufPtr = &usart_data->buffer;
	ans = (bufPtr->RX[bufPtr->RX_Tail]);
 78e:	a4 85       	ldd	r26, Z+12	; 0x0c

00000790 <.Loc.79>:
 790:	a8 0f       	add	r26, r24
 792:	b9 2f       	mov	r27, r25
 794:	b1 1d       	adc	r27, r1
 796:	13 96       	adiw	r26, 0x03	; 3
 798:	8c 91       	ld	r24, X

0000079a <.LVL26>:

	/* Advance buffer tail. */
	bufPtr->RX_Tail = (bufPtr->RX_Tail + 1) & USART_RX_BUFFER_MASK;
 79a:	94 85       	ldd	r25, Z+12	; 0x0c

0000079c <.Loc.82>:
 79c:	9f 5f       	subi	r25, 0xFF	; 255

0000079e <.Loc.83>:
 79e:	93 70       	andi	r25, 0x03	; 3

000007a0 <.Loc.84>:
 7a0:	94 87       	std	Z+12, r25	; 0x0c

000007a2 <.Loc.85>:

	return ans;
}
 7a2:	08 95       	ret

000007a4 <USART_RXComplete>:
 *  Stores received data in RX software buffer.
 *
 *  \param usart_data      The USART_data_t struct instance.
 */
bool USART_RXComplete(USART_data_t * usart_data)
{
 7a4:	fc 01       	movw	r30, r24

000007a6 <.LVL28>:
	USART_Buffer_t * bufPtr;
	bool ans;

	bufPtr = &usart_data->buffer;
	/* Advance buffer head. */
	uint8_t tempRX_Head = (bufPtr->RX_Head + 1) & USART_RX_BUFFER_MASK;
 7a6:	83 85       	ldd	r24, Z+11	; 0x0b

000007a8 <.LVL29>:
 7a8:	8f 5f       	subi	r24, 0xFF	; 255

000007aa <.Loc.95>:
 7aa:	83 70       	andi	r24, 0x03	; 3

000007ac <.LVL30>:

	/* Check for overflow. */
	uint8_t tempRX_Tail = bufPtr->RX_Tail;
 7ac:	24 85       	ldd	r18, Z+12	; 0x0c

000007ae <.LVL31>:
	uint8_t data = usart_data->usart->DATA;
 7ae:	a0 81       	ld	r26, Z
 7b0:	b1 81       	ldd	r27, Z+1	; 0x01

000007b2 <.Loc.100>:
 7b2:	9c 91       	ld	r25, X

000007b4 <.LVL32>:

	if (tempRX_Head == tempRX_Tail) {
 7b4:	82 17       	cp	r24, r18
 7b6:	49 f0       	breq	.+18     	; 0x7ca <.L15>

000007b8 <.LVL33>:
	  	ans = false;
	}else{
		ans = true;
		usart_data->buffer.RX[usart_data->buffer.RX_Head] = data;
 7b8:	a3 85       	ldd	r26, Z+11	; 0x0b

000007ba <.Loc.106>:
 7ba:	ae 0f       	add	r26, r30
 7bc:	bf 2f       	mov	r27, r31
 7be:	b1 1d       	adc	r27, r1
 7c0:	13 96       	adiw	r26, 0x03	; 3
 7c2:	9c 93       	st	X, r25

000007c4 <.Loc.107>:
		usart_data->buffer.RX_Head = tempRX_Head;
 7c4:	83 87       	std	Z+11, r24	; 0x0b

000007c6 <.Loc.109>:
		ans = true;
 7c6:	81 e0       	ldi	r24, 0x01	; 1

000007c8 <.LVL34>:
 7c8:	08 95       	ret

000007ca <.L15>:
	  	ans = false;
 7ca:	80 e0       	ldi	r24, 0x00	; 0

000007cc <.LVL36>:
	}
	return ans;
}
 7cc:	08 95       	ret

000007ce <USART_DataRegEmpty>:
 *  is empty. Argument is pointer to USART (USART_data_t).
 *
 *  \param usart_data      The USART_data_t struct instance.
 */
void USART_DataRegEmpty(USART_data_t * usart_data)
{
 7ce:	cf 93       	push	r28

000007d0 <.LCFI3>:
 7d0:	df 93       	push	r29

000007d2 <.LCFI4>:
 7d2:	fc 01       	movw	r30, r24

000007d4 <.LVL38>:
	USART_Buffer_t * bufPtr;
	bufPtr = &usart_data->buffer;

	/* Check if all data is transmitted. */
	uint8_t tempTX_Tail = usart_data->buffer.TX_Tail;
 7d4:	86 85       	ldd	r24, Z+14	; 0x0e

000007d6 <.LVL39>:
	if (bufPtr->TX_Head == tempTX_Tail){
 7d6:	95 85       	ldd	r25, Z+13	; 0x0d
 7d8:	a0 81       	ld	r26, Z
 7da:	b1 81       	ldd	r27, Z+1	; 0x01

000007dc <.Loc.122>:
 7dc:	98 13       	cpse	r25, r24
 7de:	09 c0       	rjmp	.+18     	; 0x7f2 <.L17>

000007e0 <.LBB2>:
	    /* Disable DRE interrupts. */
		uint8_t tempCTRLA = usart_data->usart->CTRLA;
 7e0:	13 96       	adiw	r26, 0x03	; 3
 7e2:	8c 91       	ld	r24, X
 7e4:	13 97       	sbiw	r26, 0x03	; 3

000007e6 <.LVL40>:
		tempCTRLA = (tempCTRLA & ~USART_DREINTLVL_gm) | USART_DREINTLVL_OFF_gc;
 7e6:	8c 7f       	andi	r24, 0xFC	; 252

000007e8 <.Loc.127>:
		usart_data->usart->CTRLA = tempCTRLA;
 7e8:	13 96       	adiw	r26, 0x03	; 3
 7ea:	8c 93       	st	X, r24

000007ec <.L16>:
		usart_data->usart->DATA = data;

		/* Advance buffer tail. */
		bufPtr->TX_Tail = (bufPtr->TX_Tail + 1) & USART_TX_BUFFER_MASK;
	}
}
 7ec:	df 91       	pop	r29
 7ee:	cf 91       	pop	r28
 7f0:	08 95       	ret

000007f2 <.L17>:
		uint8_t data = bufPtr->TX[usart_data->buffer.TX_Tail];
 7f2:	c6 85       	ldd	r28, Z+14	; 0x0e

000007f4 <.Loc.133>:
 7f4:	ce 0f       	add	r28, r30
 7f6:	df 2f       	mov	r29, r31
 7f8:	d1 1d       	adc	r29, r1
 7fa:	8f 81       	ldd	r24, Y+7	; 0x07

000007fc <.LVL44>:
		usart_data->usart->DATA = data;
 7fc:	8c 93       	st	X, r24

000007fe <.Loc.136>:
		bufPtr->TX_Tail = (bufPtr->TX_Tail + 1) & USART_TX_BUFFER_MASK;
 7fe:	86 85       	ldd	r24, Z+14	; 0x0e

00000800 <.LVL45>:
 800:	8f 5f       	subi	r24, 0xFF	; 255

00000802 <.Loc.139>:
 802:	83 70       	andi	r24, 0x03	; 3

00000804 <.Loc.140>:
 804:	86 87       	std	Z+14, r24	; 0x0e

00000806 <.LBE3>:
}
 806:	f2 cf       	rjmp	.-28     	; 0x7ec <.L16>

00000808 <USART_NineBits_PutChar>:
 *
 *  \param usart      The USART module.
 *  \param data       The data to send.
 */
void USART_NineBits_PutChar(USART_t * usart, uint16_t data)
{
 808:	fc 01       	movw	r30, r24
 80a:	cb 01       	movw	r24, r22

0000080c <.LVL48>:
	if(data & 0x0100) {
		usart->CTRLB |= USART_TXB8_bm;
 80c:	24 81       	ldd	r18, Z+4	; 0x04

0000080e <.Loc.147>:
	if(data & 0x0100) {
 80e:	70 ff       	sbrs	r23, 0
 810:	04 c0       	rjmp	.+8      	; 0x81a <.L20>

00000812 <.Loc.148>:
		usart->CTRLB |= USART_TXB8_bm;
 812:	21 60       	ori	r18, 0x01	; 1

00000814 <.L22>:
	}else {
		usart->CTRLB &= ~USART_TXB8_bm;
 814:	24 83       	std	Z+4, r18	; 0x04

00000816 <.Loc.151>:
	}

	usart->DATA = (data & 0x00FF);
 816:	80 83       	st	Z, r24

00000818 <.Loc.153>:
}
 818:	08 95       	ret

0000081a <.L20>:
		usart->CTRLB &= ~USART_TXB8_bm;
 81a:	2e 7f       	andi	r18, 0xFE	; 254
 81c:	fb cf       	rjmp	.-10     	; 0x814 <.L22>

0000081e <USART_NineBits_GetChar>:
 *  \param usart      The USART module.
 *
 *  \retval           Received data.
 */
uint16_t USART_NineBits_GetChar(USART_t * usart)
{
 81e:	fc 01       	movw	r30, r24

00000820 <.Loc.158>:
	if(usart->CTRLB & USART_RXB8_bm) {
 820:	84 81       	ldd	r24, Z+4	; 0x04

00000822 <.LVL50>:
 822:	80 ff       	sbrs	r24, 0
 824:	04 c0       	rjmp	.+8      	; 0x82e <.L24>

00000826 <.Loc.161>:
		return(0x0100 | usart->DATA);
 826:	80 81       	ld	r24, Z
 828:	90 e0       	ldi	r25, 0x00	; 0

0000082a <.Loc.163>:
 82a:	91 60       	ori	r25, 0x01	; 1
 82c:	08 95       	ret

0000082e <.L24>:
	}else {
		return(usart->DATA);
 82e:	80 81       	ld	r24, Z
 830:	90 e0       	ldi	r25, 0x00	; 0

00000832 <.Loc.166>:
	}
}
 832:	08 95       	ret

00000834 <platform_init>:
#include "hal.h"
#include "xmega_hal.h"

void platform_init(void)
{  
    OSC.XOSCCTRL = 0x00;
 834:	10 92 52 00 	sts	0x0052, r1	; 0x800052 <__TEXT_REGION_LENGTH__+0x700052>

00000838 <.Loc.3>:
    OSC.PLLCTRL = 0x00;
 838:	10 92 55 00 	sts	0x0055, r1	; 0x800055 <__TEXT_REGION_LENGTH__+0x700055>

0000083c <.Loc.5>:
    OSC.CTRL |= OSC_XOSCEN_bm;
 83c:	80 91 50 00 	lds	r24, 0x0050	; 0x800050 <__TEXT_REGION_LENGTH__+0x700050>
 840:	88 60       	ori	r24, 0x08	; 8
 842:	80 93 50 00 	sts	0x0050, r24	; 0x800050 <__TEXT_REGION_LENGTH__+0x700050>

00000846 <.L2>:
    
    //wait for clock
    while((OSC.STATUS & OSC_XOSCRDY_bm) == 0);
 846:	80 91 51 00 	lds	r24, 0x0051	; 0x800051 <__TEXT_REGION_LENGTH__+0x700051>

0000084a <.Loc.11>:
 84a:	83 ff       	sbrs	r24, 3
 84c:	fc cf       	rjmp	.-8      	; 0x846 <.L2>

0000084e <.Loc.12>:
    
    //Switch clock source
    CCP = CCP_IOREG_gc;
 84e:	88 ed       	ldi	r24, 0xD8	; 216
 850:	84 bf       	out	0x34, r24	; 52

00000852 <.Loc.14>:
    CLK.CTRL = CLK_SCLKSEL_XOSC_gc;    
 852:	83 e0       	ldi	r24, 0x03	; 3
 854:	80 93 40 00 	sts	0x0040, r24	; 0x800040 <__TEXT_REGION_LENGTH__+0x700040>

00000858 <.Loc.16>:
    
    //Turn off other sources besides external    
    OSC.CTRL = OSC_XOSCEN_bm;
 858:	88 e0       	ldi	r24, 0x08	; 8
 85a:	80 93 50 00 	sts	0x0050, r24	; 0x800050 <__TEXT_REGION_LENGTH__+0x700050>

0000085e <.Loc.18>:
    
 #if PLATFORM == CW303
    PORTA.DIRSET = PIN5_bm | PIN6_bm;
    PORTA.OUTSET = PIN5_bm | PIN6_bm;
 #endif
}
 85e:	08 95       	ret

00000860 <main>:

int main(void) {
  // Setup the specific chipset.
  platform_init();
 860:	0e 94 1a 04 	call	0x834	; 0x834 <platform_init>

00000864 <.LVL6>:
  // Setup serial communication line.
  init_uart();
 864:	0e 94 49 03 	call	0x692	; 0x692 <init_uart0>

00000868 <.LVL7>:
  // Setup measurement trigger.
  trigger_setup();
 868:	81 e0       	ldi	r24, 0x01	; 1
 86a:	80 93 01 06 	sts	0x0601, r24	; 0x800601 <__TEXT_REGION_LENGTH__+0x700601>

0000086e <.Loc.32>:

  simpleserial_init();
 86e:	0e 94 e2 01 	call	0x3c4	; 0x3c4 <simpleserial_init>

00000872 <.LVL8>:

  // Insert your handlers here.
  simpleserial_addcmd('p', 16, handle);
 872:	40 e0       	ldi	r20, 0x00	; 0
 874:	51 e0       	ldi	r21, 0x01	; 1
 876:	60 e1       	ldi	r22, 0x10	; 16
 878:	70 e0       	ldi	r23, 0x00	; 0
 87a:	80 e7       	ldi	r24, 0x70	; 112
 87c:	0e 94 b9 01 	call	0x372	; 0x372 <simpleserial_addcmd>

00000880 <.L6>:

  // What for the capture board to send commands and handle them.
  while (1)
    simpleserial_get();
 880:	0e 94 8d 02 	call	0x51a	; 0x51a <simpleserial_get>

00000884 <.LVL10>:
  while (1)
 884:	fd cf       	rjmp	.-6      	; 0x880 <.L6>

00000886 <_exit>:
 886:	f8 94       	cli

00000888 <__stop_program>:
 888:	ff cf       	rjmp	.-2      	; 0x888 <__stop_program>
